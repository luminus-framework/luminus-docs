## Security

Password hashing and comparison is provided via `noir.util.crypt` in [lib-noir](https://github.com/noir-clojure/lib-noir).

It provides two functions, `encrypt` and `compare`. The first will encrypt and salt the password,
while the second compares the raw password to the encrypted string generated by the first. BCrypt
is used to do the actual encryption.

The signature for `compare` looks as follows:

```clojure
(compare raw encrypted)
```

The `encrypt` function allows specifying the salt, or it will generate one if it is none is provided:

```clojure
(encrypt salt raw)
(encrypt raw)
```

For information on restricting access to specific routes, please refer to the [routing section](/docs/routes.md#marking_routes_as_restricted).

For a more comprehensive security solution you may wish to check out the [Friend](https://github.com/cemerick/friend) library.

## LDAP Authentication

The following example demonstrates how to authenticate with the `sAMAccountName` using the [clj-ldap](https://github.com/pauldorman/clj-ldap) library.

First, we'll add the following dependency to your `project.clj`.

```clojure
[org.clojars.pntblnk/clj-ldap "0.0.9"]
```

Next, we'll need to require the LDAP client in the authentication namespace.

```clojure
(ns ldap-auth  
  (:require [clj-ldap.client :as client]))
```

We can then define our LDAP host as follows, note that the `host` key points to a vector of LDAP servers.

```clojure
(def host
  {:host
    [{:address "my-ldap-server.ca"
      :port 389
      :connect-timeout (* 1000 5)
      :timeout (* 1000 30)}]})
```

Finally, we'll write a function to authenticate the user using the above host definition.

```clojure
(defn authenticate [username password & [attributes]]
  (let [server (client/connect host)
        qualified-name (str username "@" (-> host :host first :address))]
    (if (client/bind? server qualified-name  password)
      (first (client/search server "OU=MyOrgPeople,DC=myorg,DC=ca"
                            {:filter (str "sAMAccountName=" username)
                             :attributes (or attributes [])})))))
``` 

The `attributes` vector can be used to filter the keys that are returned, an empty vector will return all the keys associated with the account.

### Cross Site Request Forgery Protection

CSRF attack involves a third party performing an action on your site using the credentials of a logged-in user.
This can commonly occur when your site contains malicious a link, a form button, or some JavaScript.

[Ring-Anti-Forgery](https://github.com/ring-clojure/ring-anti-forgery) is used to protect against CSRF attacks. To enable it simply navigate to the `handler` namespace and change `mk-defaults` parameter to true in the `app-handler`:

```clojure
(def app (app-handler
           [home-routes base-routes]
           :middleware (load-middleware)
           ;; set this to true in order to enable CSRF protection
           :ring-defaults (mk-defaults true)
           :access-rules []
           :formats [:json-kw :edn :transit-json]))
```

Once the CSRF middleware is enabled a randomly-generated string will be assigned to the *anti-forgery-token* var.
Any POST requests coming to the server will have to contain a paremeter called `__anti-forgery-token` with 
this token.

We'll first need to add a reference to `anti-forgery` in the namespace declaration:

```clojure
(require ... [ring.util.anti-forgery :refer [anti-forgery-field]]))
```

Notice the CSRF tag is included by default in `layout.clj`:

```clojure
(parser/add-tag! :csrf-field (fn [_ _] (anti-forgery-field)))
```

you can use it in your templates as follows:

```xml
<form name="input" action="/login" method="POST">
  {% csrf-field %}
  Username: <input type="text" name="user">
  Password: <input type="password" name="pass">
  <input type="submit" value="Submit">
</form>
```

POST requests that do not contain the token will be rejected by the middleware. The server will
respond with a 403 error saying "Invalid anti-forgery token".
